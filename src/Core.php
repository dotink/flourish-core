<?php namespace Dotink\Flourish {

	/**
	 * Provides low-level debugging, error and exception functionality.
	 *
	 *
	 * @copyright  Copyright (c) 2007-2012 Will Bond, others
	 * @author     Will Bond           [wb]  <will@flourishlib.com>
	 * @author     Matthew J. Sahagian [mjs] <msahagian@dotink.org>
	 *
	 * @license    http://flourishlib.com/license
	 *
	 * @package    Flourish
	 *
	 * @todo Class properties should be changed to lowerCamelCase to fit with coding standards.
	 *
	 * Static Dependencies:
	 * - ProgrammerException
	 * - EnvironmentException
	 *
	 */

	class Core
	{
		/**
		 * A shorthand for the DIRECTORY_SEPARATOR
		 *
		 * @var string
		 */
		const DS = DIRECTORY_SEPARATOR;


		/**
		 * A regular expression to match error destinations which are e-mails
		 *
		 * @var string
		 */
		const EMAIL_DESTINATION_REGEX = '
			# Allow leading whitespace
			~^(?:

				# An "atom" or a quoted string
				(?:[^\x00-\x20\(\)<>@,;:\\\\"\.\[\]]+|"[^"\\\\\n\r]+")

				# A . plus another "atom" or a quoted string, any number of times
				(?:\.[ \t]*(?:[^\x00-\x20\(\)<>@,;:\\\\"\.\[\]]+|"[^"\\\\\n\r]+"[ \t]*))*

			# The @ symbol
			)@(?:

				# Domain name
				(?:[a-z0-9\\-]+\.)+[a-z]{2,}|

				# (or) IP addresses
				(?:(?:[01]?\d?\d|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d?\d|2[0-4]\d|25[0-5])
			)

			# Any number of other emails separated by a comma with surrounding spaces
			(?:\s*,\s*
				(?:
					(?:[^\x00-\x20\(\)<>@,;:\\\\"\.\[\]]+|"[^"\\\\\n\r]+")
					(?:\.[ \t]*(?:[^\x00-\x20\(\)<>@,;:\\\\"\.\[\]]+|"[^"\\\\\n\r]+"[ \t]*))*
				)@(?:
					(?:[a-z0-9\\-]+\.)+[a-z]{2,}|
					(?:(?:[01]?\d?\d|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d?\d|2[0-4]\d|25[0-5])
				)
			)*$~xiD
		';


		/**
		 * The nesting level of error capturing
		 *
		 * @static
		 * @access private
		 * @var integer
		 */
		static private $captured_error_level = 0;


		/**
		 * A stack of regex to match errors to capture, one string per level
		 *
		 * @static
		 * @access private
		 * @var array
		 */
		static private $captured_error_regex = array();


		/**
		 * A stack of the types of errors to capture, one integer per level
		 *
		 * @static
		 * @access private
		 * @var array
		 */
		static private $captured_error_types = array();


		/**
		 * A stack of arrays of errors that have been captured, one array per level
		 *
		 * @static
		 * @access private
		 * @var array
		 */
		static private $captured_errors = array();


		/**
		 * If the context info has been shown
		 *
		 * @static
		 * @access private
		 * @var boolean
		 */
		static private $context_shown = FALSE;


		/**
		 * If global debugging is enabled
		 *
		 * @static
		 * @access private
		 * @var boolean
		 */
		static private $debug = NULL;


		/**
		 * A callback to pass debug messages to
		 *
		 * @static
		 * @access private
		 * @var callback
		 */
		static private $debug_callback = NULL;


		/**
		 * Error destination
		 *
		 * @static
		 * @access private
		 * @var string
		 */
		static private $error_destination = 'html';


		/**
		 * An array of errors to be send to the destination upon page completion
		 *
		 * @static
		 * @access private
		 * @var array
		 */
		static private $error_message_queue = array();


		/**
		 * Exception destination
		 *
		 * @static
		 * @access private
		 * @var string
		 */
		static private $exception_destination = 'html';


		/**
		 * Exception handler callback
		 *
		 * @static
		 * @access private
		 * @var mixed
		 */
		static private $exception_handler_callback = NULL;


		/**
		 * Exception handler callback parameters
		 *
		 * @static
		 * @access private
		 * @var array
		 */
		static private $exception_handler_parameters = array();


		/**
		 * The message generated by the uncaught exception
		 *
		 * @static
		 * @access private
		 * @var string
		 */
		static private $exception_message = NULL;


		/**
		 * If this class is handling errors
		 *
		 * @static
		 * @access private
		 * @var boolean
		 */
		static private $handles_errors = FALSE;


		/**
		 * If this class is handling exceptions
		 *
		 * @static
		 * @access private
		 * @var boolean
		 */
		static private $handles_exceptions = FALSE;


		/**
		 * A stack of the previous error handler, one callback per level
		 *
		 * @static
		 * @access private
		 * @var array
		 */
		static private $previous_error_handler = array();


		/**
		 * If the context info should be shown with errors/exceptions
		 *
		 * @static
		 * @access private
		 * @var boolean
		 */
		static private $show_context = TRUE;


		/**
		 * An array of the most significant lines from error and exception backtraces
		 *
		 * @static
		 * @access private
		 * @var array
		 */
		static private $significant_error_lines = array();


		/**
		 * An SMTP connection for sending error and exception emails
		 *
		 * @static
		 * @access private
		 * @var SMTP
		 */
		static private $smtp_connection = NULL;


		/**
		 * The email address to send error emails from
		 *
		 * @static
		 * @access private
		 * @var string
		 */
		static private $smtp_from_email = NULL;


		/**
		 * Creates a nicely formatted backtrace to the the point where this method is called
		 *
		 * @static
		 * @access public
		 * @param integer $remove_lines The number of trailing lines to remove from the backtrace
		 * @param array $backtrace A backtrace from `debug_backtrace()` to format
		 * @return string The formatted backtrace
		 */
		static public function backtrace($remove_lines = 0, $backtrace = NULL)
		{
			if ($remove_lines !== NULL && !is_numeric($remove_lines)) {
				$remove_lines = 0;
			}

			settype($remove_lines, 'integer');

			$doc_root  = realpath($_SERVER['DOCUMENT_ROOT']);
			$doc_root .= (substr($doc_root, -1) != self::DS) ? self::DS : '';

			if ($backtrace === NULL) {
				$backtrace = debug_backtrace();
			}

			while ($remove_lines > 0) {
				array_shift($backtrace);
				$remove_lines--;
			}

			$backtrace = array_reverse($backtrace);
			$bt_string = '';
			$i         = 0;

			foreach ($backtrace as $call) {
				if ($i) {
					$bt_string .= "\n";
				}

				if (isset($call['file'])) {
					$bt_string .= str_replace($doc_root, '{doc_root}' . self::DS, $call['file']);
					$bt_string .= '(' . $call['line'] . '): ';

				} else {
					$bt_string .= '[internal function]: ';
				}

				if (isset($call['class'])) {
					$bt_string .= $call['class'] . $call['type'];
				}

				if (isset($call['class']) || isset($call['function'])) {
					$bt_string .= $call['function'] . '(';
						$j = 0;
						if (!isset($call['args'])) {
							$call['args'] = array();
						}
						foreach ($call['args'] as $arg) {
							if ($j) {
								$bt_string .= ', ';
							}
							if (is_bool($arg)) {
								$bt_string .= ($arg) ? 'true' : 'false';
							} elseif (is_null($arg)) {
								$bt_string .= 'NULL';
							} elseif (is_array($arg)) {
								$bt_string .= 'Array';
							} elseif (is_object($arg)) {
								$bt_string .= 'Object(' . get_class($arg) . ')';
							} elseif (is_string($arg)) {
								// Shorten the UTF-8 string if it is too long
								if (strlen(utf8_decode($arg)) > 18) {
									// If we can't match as unicode, try single byte
									if (!preg_match('#^(.{0,15})#us', $arg, $short_arg)) {
										preg_match('#^(.{0,15})#s', $arg, $short_arg);
									}
									$arg  = $short_arg[0] . '...';
								}
								$bt_string .= "'" . $arg . "'";
							} else {
								$bt_string .= (string) $arg;
							}
							$j++;
						}
					$bt_string .= ')';
				}
				$i++;
			}

			return $bt_string;
		}


		/**
		 * Returns is the current OS is one of the OSes passed as a parameter
		 *
		 * Valid OS strings are:
		 *  - `'linux'`
		 *  - `'aix'`
		 *  - `'bsd'`
		 *  - `'freebsd'`
		 *  - `'netbsd'`
		 *  - `'openbsd'`
		 *  - `'osx'`
		 *  - `'solaris'`
		 *  - `'windows'`
		 *
		 * @static
		 * @access public
		 * @param string $os The operating system to check
		 * @param string ...
		 * @return boolean If the current OS is in the list of OSes passed as parameters
		 */
		static public function checkOS($os)
		{
			$oses       = func_get_args();
			$valid_oses = [
				'linux', 'aix', 'bsd', 'freebsd', 'openbsd', 'netbsd', 'osx', 'solaris', 'windows'
			];

			if ($invalid_oses = array_diff($oses, $valid_oses)) {
				throw new ProgrammerException(
					'One or more of the OSes specified, %$1s, is invalid. Must be one of: %2$s.',
					join(' ',  $invalid_oses),
					join(', ', $valid_oses)
				);
			}

			$uname = php_uname('s');

			if (stripos($uname, 'linux') !== FALSE) {
				return in_array('linux', $oses);

			} elseif (stripos($uname, 'aix') !== FALSE) {
				return in_array('aix', $oses);

			} elseif (stripos($uname, 'netbsd') !== FALSE) {
				return in_array('netbsd', $oses) || in_array('bsd', $oses);

			} elseif (stripos($uname, 'openbsd') !== FALSE) {
				return in_array('openbsd', $oses) || in_array('bsd', $oses);

			} elseif (stripos($uname, 'freebsd') !== FALSE) {
				return in_array('freebsd', $oses) || in_array('bsd', $oses);

			} elseif (stripos($uname, 'solaris') !== FALSE) {
				return in_array('solaris', $oses);

			} elseif (stripos($uname, 'sunos') !== FALSE) {
				return in_array('solaris', $oses);

			} elseif (stripos($uname, 'windows') !== FALSE) {
				return in_array('windows', $oses);

			} elseif (stripos($uname, 'darwin') !== FALSE) {
				return in_array('osx', $oses);
			}

			throw new EnvironmentException('Unable to determine the current OS');
		}


		/**
		 * Checks the current SAPI name
		 *
		 * @static
		 * @access public
		 * @param string $sapi The SAPI to verify running
		 * @return boolean TRUE if the running SAPI matches, FALSE otherwise
		 */
		static public function checkSAPI($sapi)
		{
			return (strtolower(php_sapi_name()) == strtolower($sapi));
		}


		/**
		 * Checks to see if the running version of PHP is greater or equal to the version passed
		 *
		 * @static
		 * @access public
		 * @return boolean If the running version of PHP is greater or equal to the version passed
		 */
		static public function checkVersion($version)
		{
			static $running_version = NULL;

			if ($running_version === NULL) {
				$running_version = preg_replace(
					'#^(\d+\.\d+\.\d+).*$#D',
					'\1',
					PHP_VERSION
				);
			}

			return version_compare($running_version, $version, '>=');
		}


		/**
		 * Composes text using Text if loaded
		 *
		 * This method does not support domains and is designed for internal composition only.
		 *
		 * @static
		 * @access public
		 * @param string $message The message to compose
		 * @param mixed $component A string or number to insert into the message
		 * @param mixed ...
		 * @return string The composed and possible translated message
		 */
		static public function compose($message)
		{
			$components = array_slice(func_get_args(), 1);

			//
			// Handles components passed as an array
			//

			if (sizeof($components) == 1 && is_array($components[0])) {
				$components = $components[0];
			}

			if (class_exists($text_class = __NAMESPACE__ . '\Text')) {
				return Text::create($message)->compose(NULL, $components);
			} else {
				return vsprintf($message, $components);
			}
		}


		/**
		 * Sets an SMTP object to be used for sending error and exception emails
		 *
		 * @static
		 * @access public
		 * @param fSMTP $smtp The SMTP connection to send emails over
		 * @param string $from_email The email address to use in the `From:` header
		 * @return void
		 */
		static public function configureSMTP($smtp, $from_email)
		{
			self::$smtp_connection = $smtp;
			self::$smtp_from_email = $from_email;
		}


		/**
		 * Prints a debugging message if global or code-specific debugging is enabled
		 *
		 * @static
		 * @access public
		 * @param string $message The debug message
		 * @param boolean $force If debugging should be forced even when global debugging is off
		 * @return void
		 */
		static public function debug($message, $force = FALSE)
		{
			if ($force || self::$debug) {
				if (self::$debug_callback) {
					call_user_func(self::$debug_callback, $message);
				} else {
					self::expose($message);
				}
			}
		}


		/**
		 * Creates a string representation of any variable using predefined strings for booleans,
		 * `NULL` and empty strings
		 *
		 * The string output format of this method is very similar to the output of `print_r()`
		 * except that the following values are represented as special strings:
		 *
		 *  - `TRUE`: `'{true}'`
		 *  - `FALSE`: `'{false}'`
		 *  - `NULL`: `'{null}'`
		 *  - `''`: `'{empty_string}'`
		 *
		 * @static
		 * @access public
		 * @param mixed $data The value to dump
		 * @return string The string representation of the value
		 */
		static public function dump($data)
		{
			if (is_bool($data)) {
				return ($data) ? '{true}' : '{false}';

			} elseif (is_null($data)) {
				return '{null}';

			} elseif ($data === '') {
				return '{empty_string}';

			} elseif (is_array($data) || is_object($data)) {

				ob_start();
				var_dump($data);

				$output       = ob_get_clean();
				$matches      = [
					0  => '#=>\n(  )+(?=[a-zA-Z]|&)#m',
					1  =>'#string\(0\) ""#',
					2  => '#=> (&)?NULL#',
					3  => '#=> (&)?bool\((false|true)\)#',
					4  => '#(?<=^|\] => )(?:float|int)\((-?\d+(?:.\d+)?)\)#',
					5  => '#string\(\d+\) "#',
					6  => '#"(\n(  )*)(?=\[|\})#',
					7  => '#((?:  )+)\["(.*?)"\]#',
					8  =>'#(?:&)?array\(\d+\) \{\n((?:  )*)((?:  )(?=\[)|(?=\}))#',
					9  => '#object\((\w+)\)\#\d+ \(\d+\) {\n((?:  )*)((?:  )(?=\[)|(?=\}))#',
					10 => '#^((?:  )+)}(?=\n|$)#m'
				];

				$replacements = [
					0  => ' => ',
					1  => '{empty_string}',
					2  => '=> \1{null}',
					3  => '=> \1{\2}',
					4  => '\1',
					5  => '',
					6  => '\1',
					7  => '\1[\2]',
					8  => "Array\n\\1(\n\\1\\2",
					9  => "\\1 Object\n\\2(\n\\2\\3",
					10 => "\\1)\n"
				];

				foreach ($matches as $i => $regex) {
					$output = preg_replace($regex, $replacements[$i], $output);
				}

				$output = substr($output, 0, -2) . ')';

				// Fix indenting issues with the var dump output
				$output_lines = explode("\n", $output);
				$new_output = array();
				$stack = 0;
				foreach ($output_lines as $line) {
					if (preg_match('#^((?:  )*)([^ ])#', $line, $match)) {
						$spaces = strlen($match[1]);
						if ($spaces && $match[2] == '(') {
							$stack += 1;
						}
						$new_output[] = str_pad('', ($spaces)+(4*$stack)) . $line;
						if ($spaces && $match[2] == ')') {
							$stack -= 1;
						}
					} else {
						$new_output[] = str_pad('', ($spaces)+(4*$stack)) . $line;
					}
				}

				return join("\n", $new_output);

			} else {
				return (string) $data;
			}
		}


		/**
		 * Disables including the context information with exception and error messages
		 *
		 * The context information includes the following superglobals:
		 *
		 *  - `$_SERVER`
		 *  - `$_POST`
		 *  - `$_GET`
		 *  - `$_SESSION`
		 *  - `$_FILES`
		 *  - `$_COOKIE`
		 *
		 * @static
		 * @access public
		 * @return void
		 */
		static public function disableContext()
		{
			self::$show_context = FALSE;
		}


		/**
		 * Enables debug messages globally, i.e. they will be shown for any call to ::debug()
		 *
		 * @static
		 * @access public
		 * @param boolean $flag If debugging messages should be shown
		 * @return void
		 */
		static public function enableDebugging($flag)
		{
			self::$debug = (boolean) $flag;
		}


		/**
		 * Turns on developer-friendly error handling that includes context information including a
		 * backtrace and superglobal dumps
		 *
		 * All errors that match the current `error_reporting()` level will be redirected to the
		 * destination and will include a full backtrace. In addition, dumps of the following
		 * superglobals will be made to aid in debugging:
		 *
		 *  - `$_SERVER`
		 *  - `$_POST`
		 *  - `$_GET`
		 *  - `$_SESSION`
		 *  - `$_FILES`
		 *  - `$_COOKIE`
		 *
		 * The superglobal dumps are only done once per page, however a backtrace in included for
		 * each error.
		 *
		 * If an email address is specified for the destination, only one email will be sent per
		 * script execution. If both error and ::enableExceptionHandling() exception handling are
		 * set to the same email address, the email will contain both errors and exceptions.
		 *
		 * The error destination can be either an e-mail, a list of comma separated e-mails, a
		 * file path, or the string `'html'`.
		 *
		 * @static
		 * @access public
		 * @param string $destination The error destination
		 * @return void
		 */
		static public function enableErrorHandling($destination)
		{
			if (!self::checkDestination($destination)) {
				return;
			}
			self::$error_destination = $destination;
			self::$handles_errors    = TRUE;
			set_error_handler([__CLASS__, 'handleError']);
		}


		/**
		 * Turns on developer-friendly uncaught exception handling that includes context
		 * information including a backtrace and superglobal dumps
		 *
		 * Any uncaught exception will be redirected to the destination specified, and the page
		 * will execute the `$closing_code` callback before exiting.  The destination will receive
		 * a message with the exception messaage, a full backtrace and dumps of the following
		 * superglobals to aid in debugging:
		 *
		 *  - `$_SERVER`
		 *  - `$_POST`
		 *  - `$_GET`
		 *  - `$_SESSION`
		 *  - `$_FILES`
		 *  - `$_COOKIE`
		 *
		 * The superglobal dumps are only done once per page, however a backtrace in included for
		 * each error.
		 *
		 * If an email address is specified for the destination, only one email will be sent per
		 * script execution.
		 *
		 * If an email address is specified for the destination, only one email will be sent per
		 * script execution. If both exception and ::enableErrorHandling() error handling are set
		 * to the same email address, the email will contain both exceptions and errors.
		 *
		 * The exception destination can be either an e-mail, a list of comma separated e-mails, a
		 * file path, or the string `'html'`.
		 *
		 * @static
		 * @access public
		 * @param string $destination The exception destination
		 * @param callback $closing_code A callback executed after the exception
		 * @param array $parameters  The parameters to send to `$closing_code`
		 * @return void
		 */
		static public function enableExceptionHandling($destination, $closing_code = NULL, $parameters = array())
		{
			if (!self::checkDestination($destination)) {
				return;
			}

			self::$handles_exceptions         = TRUE;
			self::$exception_destination      = $destination;
			self::$exception_handler_callback = $closing_code;

			if (!is_object($parameters)) {
				settype($parameters, 'array');

			} else {
				$parameters = array($parameters);
			}

			self::$exception_handler_parameters = $parameters;

			set_exception_handler([__CLASS__, 'handleException']);
		}


		/**
		 * Prints the ::dump() of a value
		 *
		 * The dump will be printed in a `<pre>` tag with the class `exposed` if PHP is running
		 * anywhere but via the command line (cli). If PHP is running via the cli, the data will
		 * be printed, followed by a single line break (`\n`).
		 *
		 * If multiple parameters are passed, they are exposed as an array.
		 *
		 * @static
		 * @access public
		 * @param mixed $data The value to show
		 * @param mixed ...
		 * @return void
		 */
		static public function expose($data)
		{
			$args = func_get_args();

			if (count($args) > 1) {
				$data = $args;
			}

			if (!self::checkSAPI('cli')) {
				echo '<pre class="exposed">';
				echo htmlspecialchars((string) self::dump($data), ENT_QUOTES);
				echo '</pre>';

			} else {
				echo self::dump($data) . "\n";
			}
		}


		/**
		 * Determines whether or not debugging is enabled
		 *
		 * @static
		 * @access public
		 * @param boolean $force If debugging is forced
		 * @return boolean If debugging is enabled
		 */
		static public function getDebug($force = FALSE)
		{
			return self::$debug || $force;
		}


		/**
		 * Handles an error, creating the necessary context information and sending it to the
		 * specified destination
		 *
		 * @internal
		 *
		 * @static
		 * @access public
		 * @param integer $number The error type
		 * @param string $message The message for the error
		 * @param string $file The file the error occurred in
		 * @param integer $line The line the error occurred on
		 * @param array $context A references to all variables in scope when the error occurred
		 * @return void
		 */
		static public function handleError($number, $message, $file = NULL, $line = NULL, $context = NULL)
		{
			$capturing   = (bool) self::$captured_error_level;
			$level_match = (bool) (error_reporting() & $number);

			if (!$capturing && !$level_match) {
				return;
			}

			$backtrace = self::backtrace(1);
			$root      = realpath($_SERVER['DOCUMENT_ROOT']);

			if (!in_array(substr($root, -1), ['/', '\\', self::DS])) {
				$root .= self::DS;
			}

			//
			// Remove the reference to handleError
			//

			$rx_method = preg_quote(__CLASS__ . '::handleError', '#');
			$backtrace = preg_replace('#: ' . $rx_method . '\(.*?\)$#', '', $backtrace);
			$message   = preg_replace('# \[<a href=\'.*?</a>\]: #', ': ', $message);

			switch ($number) {
				case E_WARNING:           $type = self::compose('Warning');           break;
				case E_NOTICE:            $type = self::compose('Notice');            break;
				case E_USER_ERROR:        $type = self::compose('User Error');        break;
				case E_USER_WARNING:      $type = self::compose('User Warning');      break;
				case E_USER_NOTICE:       $type = self::compose('User Notice');       break;
				case E_STRICT:            $type = self::compose('Strict');            break;
				case E_RECOVERABLE_ERROR: $type = self::compose('Recoverable Error'); break;
				case E_DEPRECATED:        $type = self::compose('Deprecated');        break;
				case E_USER_DEPRECATED:   $type = self::compose('User Deprecated');   break;
			}

			if ($capturing) {
				$is_type_to_capture   = self::isCaptureType($number);
				$is_string_to_capture = self::isCaptureString($message);

				if ($is_type_to_capture && $is_string_to_capture) {
					self::$captured_errors[self::$captured_error_level][] = array(
						'number'    => $number,
						'type'      => $type,
						'string'    => $message,
						'file'      => str_replace($root, '{doc_root}/', $error_file),
						'line'      => $line,
						'backtrace' => $backtrace,
						'context'   => $context
					);
					return;
				}

				//
				// If the old handler is not this method, then we must have been trying to match a
				// regex and failed so we pass the error on to the original handler to do its thing
				//

				if (!self::checkPreviousErrorHandler([__CLASS__, __FUNCTION__])) {
					if (self::checkPreviousErrorHandler(NULL)) {
						return FALSE;
					}

					return call_user_func(
						self::$previous_error_handler[self::$captured_error_level],
						$number,
						$message,
						$file,
						$line,
						$context
					);

				//
				// If we get here, this method is the error handler, but we don't want to actually
				// report the error so we return
				//

				} elseif (!$level_match) {
					return;
				}
			}

			$backtrace_lines = explode("\n", $backtrace);
			$underline       = str_pad('', strlen($type), '-');
			$error           = implode("\n", [$type, $underline, $backtrace, $message]);

			self::sendMessageToDestination('error', $error, end($backtrace_lines));
		}


		/**
		 * Handles an uncaught exception, creating the necessary context information, sending it to
		 * the specified destination and finally executing the closing callback
		 *
		 * @internal
		 *
		 * @static
		 * @access public
		 * @param Exception $exception The uncaught exception to handle
		 * @return void
		 */
		static public function handleException($exception)
		{
			$code = ($exception->getCode())
				? ' (code ' . $exception->getCode() . ')'
				: '';

			$message = ($exception->getMessage())
				? $exception->getMessage()
				: '{no message}';

			$trace = !($exception instanceof Exception)
				? $exception->getTraceAsString()
				: $exception->formatTrace();

			$info        = $trace . "\n" . $message . $code;
			$headline    = self::compose("Uncaught") . " " . get_class($exception);
			$underline   = str_pad('', strlen($headline), '-');
			$info_block  = $headline . "\n" . $underline . "\n" . trim($info);
			$trace_lines = explode("\n", $trace);

			self::sendMessageToDestination('exception', $info_block, end($trace_lines));

			if (self::$exception_handler_callback === NULL) {
				if (self::$exception_destination != 'html' && $exception instanceof fException) {
					$exception->printMessage();
				}

				return;
			}

			try {
				call_user_func_array(
					self::$exception_handler_callback,
					self::$exception_handler_parameters
				);

			} catch (Exception $e) {
				trigger_error(
					self::compose(
						'An exception was thrown in the %s closing code callback',
						'setExceptionHandling()'
					),
					E_USER_ERROR
				);
			}
		}


		/**
		 * Registers a callback to handle debug messages instead of the default action of calling
		 * `Core::expose()` on the message
		 *
		 * @static
		 * @access public
		 * @param callback $callback A singke parameter callback that accepts the debug message
		 * @return void
		 */
		static public function registerDebugCallback($callback)
		{
			self::$debug_callback = $callback;
		}


		/**
		 * Resets the configuration of the class
		 *
		 * @internal
		 *
		 * @static
		 * @access public
		 * @return void
		 */
		static public function reset()
		{
			if (self::$handles_errors) {
				restore_error_handler();
			}
			if (self::$handles_exceptions) {
				restore_exception_handler();
			}

			if (is_array(self::$captured_errors)) {
				restore_error_handler();
			}

			self::$captured_error_level             = 0;
			self::$captured_error_regex             = array();
			self::$captured_error_types             = array();
			self::$captured_errors                  = array();
			self::$context_shown                    = FALSE;
			self::$debug                            = NULL;
			self::$debug_callback                   = NULL;
			self::$dynamic_constants                = FALSE;
			self::$error_destination                = 'html';
			self::$error_message_queue              = array();
			self::$exception_destination            = 'html';
			self::$exception_handler_callback       = NULL;
			self::$exception_handler_parameters     = array();
			self::$exception_message                = NULL;
			self::$handles_errors                   = FALSE;
			self::$handles_exceptions               = FALSE;
			self::$previous_errror_handler          = array();
			self::$significant_error_lines          = array();
			self::$show_context                     = TRUE;
			self::$smtp_connection                  = NULL;
			self::$smtp_from_email                  = NULL;
		}


		/**
		 * Sends an email or writes a file with messages generated during the page execution
		 *
		 * This method prevents multiple emails from being sent or a log file from being written
		 * multiple times for one script execution.
		 *
		 * @internal
		 *
		 * @static
		 * @access public
		 * @return void
		 */
		static public function sendMessagesOnShutdown()
		{
			$messages = array();

			if (self::$error_message_queue) {
				$message                            = join("\n\n", self::$error_message_queue);
				$messages[self::$error_destination] = $message;
			}

			if (self::$exception_message) {
				if (isset($messages[self::$exception_destination])) {
					$messages[self::$exception_destination] .= "\n\n";

				} else {
					$messages[self::$exception_destination] = '';
				}

				$messages[self::$exception_destination] .= self::$exception_message;
			}

			$hash = md5(join('', self::$significant_error_lines), TRUE);
			$hash = strtr(base64_encode($hash), '/', '-');
			$hash = substr(rtrim($hash, '='), 0, 8);

			$first_file_line = preg_replace(
				'#^.*[/\\\\](.*)$#',
				'\1',
				reset(self::$significant_error_lines)
			);

			$subject = self::compose(
				'[%1$s] %2$s error(s) beginning at %3$s {%4$s}',
				isset($_SERVER['SERVER_NAME']) ? $_SERVER['SERVER_NAME'] : php_uname('n'),
				count($messages),
				$first_file_line,
				$hash
			);

			foreach ($messages as $destination => $message) {
				if (self::$show_context) {
					$message .= "\n\n" . self::generateContext();
				}

				if (self::checkDestination($destination) == 'email') {
					if (self::$smtp_connection) {
						$email = new Email();

						foreach (explode(',', $destination) as $recipient) {
							$email->addRecipient($recipient);
						}

						$email->setFromEmail(self::$smtp_from_email);
						$email->setSubject($subject);
						$email->setBody($message);
						$email->send(self::$smtp_connection);

					} else {
						mail($destination, $subject, $message);
					}

				} else {
					$handle = fopen($destination, 'a');

					fwrite($handle, $subject . "\n\n");
					fwrite($handle, $message . "\n\n");
					fclose($handle);
				}
			}
		}


		/**
		 * Temporarily enables capturing error messages
		 *
		 * @static
		 * @access public
		 * @param integer $types The error types to capture, defaults to all (E_ALL | E_STRICT)
		 * @param string $regex A PCRE regex to match against the error message
		 * @return void
		 */
		static public function startErrorCapture($types = NULL, $regex = NULL)
		{
			if ($types === NULL) {
				$types = E_ALL | E_STRICT;
			}

			self::$captured_error_level++;

			self::$captured_error_regex[self::$captured_error_level]   = $regex;
			self::$captured_error_types[self::$captured_error_level]   = $types;
			self::$captured_errors[self::$captured_error_level]        = array();
			self::$previous_error_handler[self::$captured_error_level] = set_error_handler(
				[__CLASS__, 'handleError']
			);
		}


		/**
		 * Stops capturing error messages, returning all that have been captured
		 *
		 * @static
		 * @access public
		 * @param string $regex A PCRE regex to filter messages by
		 * @return array The captured error messages
		 */
		static public function stopErrorCapture($regex = NULL)
		{
			$captures     = self::$captured_errors[self::$captured_error_level];
			$error_stacks = [
				'captured_error_regex',
				'captured_error_types',
				'captured_errors',
				'previous_error_handler'
			];

			self::$captured_error_level--;

			foreach ($error_stacks as $error_stack) {
				self::$$error_stack = array_slice(
					self::$$error_stack,
					0,
					self::$captured_error_level,
					TRUE
				);
			}

			restore_error_handler();

			if ($regex) {
				$new_captures = array();

				foreach ($captures as $capture) {
					if (!preg_match($regex, $capture['string'])) { continue; }
					$new_captures[] = $capture;
				}

				$captures = $new_captures;
			}

			return $captures;
		}


		/**
		 * Checks an error/exception destination to make sure it is valid
		 *
		 * @static
		 * @access private
		 * @param  string $destination  The destination for the exception.
		 * @return string `'email'`, `'file'`, `'html'`
		 * @return boolean `FALSE` on error
		 */
		static private function checkDestination($destination)
		{
			if ($destination == 'html') {
				return 'html';
			}

			if (preg_match(self::EMAIL_DESTINATION_REGEX, $destination)) {
				return 'email';
			}

			$path_info     = pathinfo($destination);
			$dir_exists    = file_exists($path_info['dirname']);
			$dir_writable  = ($dir_exists) ? is_writable($path_info['dirname']) : FALSE;
			$file_exists   = file_exists($destination);
			$file_writable = ($file_exists) ? is_writable($destination) : FALSE;

			$no_file_dir_not_writable     = !$file_exists && !$dir_writable;
			$file_exists_dir_not_writable =  $file_exists && !$file_writable;

			if (!$dir_exists || ($no_file_dir_not_writable || $file_exists_dir_not_writable)) {
				return FALSE;
			}

			return 'file';
		}


		/**
		 * Checks whether or not a previous error handler matches a certain callback
		 *
		 * @static
		 * @access private
		 * @param callable $handler A handler callback to check against
		 * @return boolean TRUE if the $handler matches the previous error handler, FALSE otherwise
		 */
		static private function checkPreviousErrorHandler($handler)
		{
			return $handler == NULL
				? self::$previous_error_handler[self::$captured_error_level] === NULL
				: self::$previous_error_handler[self::$captured_error_level] == $handler;
		}


		/**
		 * Generates some information about the context of an error or exception
		 *
		 * The dump information contains the followinged superglobals:
		 *
		 * `$_SERVER`, `$_GET`, `$_POST`, `$_FILES`, `$_SESSION` and `$_COOKIE`
		 *
		 * @static
		 * @access private
		 * @return string A string containing dumped context information.
		 */
		static private function generateContext()
		{
			return self::compose('Context')                                            .
			    "\n-------"                                                            .
				"\n\n\$_SERVER: "  . self::dump($_SERVER)                              .
				"\n\n\$_POST: "    . self::dump($_POST)                                .
				"\n\n\$_GET: "     . self::dump($_GET)                                 .
				"\n\n\$_FILES: "   . self::dump($_FILES)                               .
				"\n\n\$_SESSION: " . self::dump((isset($_SESSION)) ? $_SESSION : NULL) .
				"\n\n\$_COOKIE: "  . self::dump($_COOKIE);
		}


		/**
		 * Determine whether or not we should capture an error based on number
		 *
		 * @static
		 * @access private
		 * @param integer $number The error number
		 * @return boolean Whether or not this is a capturable type
		 */
		static private function isCaptureType($number)
		{
			return (bool) self::$captured_error_types[self::$captured_error_level] & $number;
		}


		/**
		 * Determine whether or not we should cpature an error based on message
		 *
		 * @static
		 * @access private
		 * @param string $message The error message
		 * @return boolean Whether or not this is a capturable message
		 */
		static private function isCaptureString($message)
		{
			return !self::$captured_error_regex[self::$captured_error_level] || (
				self::$captured_error_regex[self::$captured_error_level] &&
				preg_match(self::$captured_error_regex[self::$captured_error_level], $message)
			);
		}


		/**
		 * Handles sending a message to a destination
		 *
		 * If the destination is an email address or file, the messages will be spooled up until
		 * the end of the script execution to prevent multiple emails from being sent or a log file
		 * being written to multiple times.
		 *
		 * @static
		 * @access private
		 * @param string $type If the message is an error or an exception
		 * @param string $message The message to send to the destination
		 * @param string $significant_line The most significant line from a backtrace
		 * @return void
		 */
		static private function sendMessageToDestination($type, $message, $significant_line)
		{
			$destination = ($type == 'exception')
				? self::$exception_destination
				: self::$error_destination;

			if ($destination == 'html') {
				if (self::$show_context && !self::$context_shown) {
					self::expose(self::generateContext());
					self::$context_shown = TRUE;
				}

				self::expose($message);

				return;
			}

			static $registered_function = FALSE;

			if (!$registered_function) {
				register_shutdown_function(self::sendMessagesOnShutdown);
				$registered_function = TRUE;

			}

			if ($type == 'error') {
				self::$error_message_queue[] = $message;

			} else {
				self::$exception_message = $message;
			}

			self::$significant_error_lines[] = $significant_line;
		}


		/**
		 * Forces use as a static class
		 *
		 * @access private
		 * @return void
		 */
		private function __construct() { }
	}
}
